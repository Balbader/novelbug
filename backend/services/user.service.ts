import * as model from '../models/user.model';
import { type usersTable } from '@/drizzle/schemas/users';

export const usersService = {
	async createUser(user: typeof usersTable.$inferInsert) {
		if (!user) {
			throw new Error('User not provided');
		}
		if (!user.kinde_id) {
			throw new Error('Kinde ID not provided');
		}

		// Check if user already exists before creating
		try {
			const existingUser = await this.getByKindeId(user.kinde_id);
			// User already exists, return it
			return existingUser;
		} catch (err) {
			// User doesn't exist, proceed with creation
		}

		// id is auto-generated by the database, so we don't need to provide it
		const data: typeof usersTable.$inferInsert = {
			kinde_id: user.kinde_id,
			username: user.username,
			email: user.email,
			first_name: user.first_name,
			last_name: user.last_name,
			date_of_birth: user.date_of_birth,
			country: user.country,
			is_password_reset_requested: user.is_password_reset_requested,
			is_suspended: user.is_suspended,
			user_since: user.user_since,
			last_login: user.last_login,
			login_count: user.login_count,
			created_at: user.created_at,
		};
		// Only include id if explicitly provided
		if (user.id) {
			data.id = user.id;
		}

		try {
			const result = await model.usersModel.create(data);
			// Return the created user from the insert result
			return result[0];
		} catch (createErr: any) {
			// If creation fails due to unique constraint, user might have been created
			// between our check and the insert (race condition)
			if (
				createErr?.message?.includes('UNIQUE constraint') ||
				createErr?.message?.includes('duplicate') ||
				createErr?.code === 'SQLITE_CONSTRAINT_UNIQUE'
			) {
				// Try to get the existing user
				try {
					const existingUser = await this.getByKindeId(user.kinde_id);
					return existingUser;
				} catch (getErr) {
					// Re-throw original error if we still can't find the user
					throw createErr;
				}
			}
			// Re-throw if it's a different error
			throw createErr;
		}
	},
	async update(
		userId: string,
		userData: Partial<typeof usersTable.$inferInsert>,
	) {
		const result = await model.usersModel.update(userId, userData);
		// Return the updated user from the update result
		if (result.length === 0) {
			throw new Error('User not found');
		}
		return result[0];
	},
	async getAll() {
		const users = await model.usersModel.getAll();
		return users;
	},
	async getByKindeId(kindeId: string) {
		const users = await model.usersModel.getByKindeId(kindeId);
		if (users.length === 0) {
			throw new Error('User not found');
		}
		return users[0];
	},
	async getByUsername(username: string) {
		const users = await model.usersModel.getByUsername(username);
		if (users.length === 0) {
			throw new Error('User not found');
		}
		return users[0];
	},
	async getByEmail(email: string) {
		const users = await model.usersModel.getByEmail(email);
		if (users.length === 0) {
			throw new Error('User not found');
		}
		return users[0];
	},
	async getById(id: string) {
		const users = await model.usersModel.getById(id);
		if (users.length === 0) {
			throw new Error('User not found');
		}
		return users[0];
	},
	async incrementLoginCount(kindeId: string) {
		const result = await model.usersModel.updateLoginCount(kindeId);
		if (result.length === 0) {
			throw new Error('User not found');
		}
		return result[0];
	},
	async delete(userId: string) {
		const result = await model.usersModel.delete(userId);
		if (result.length === 0) {
			throw new Error('User not found');
		}
		return result[0];
	},
};
